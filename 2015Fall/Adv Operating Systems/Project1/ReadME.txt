What Linux platform do you use?I use the Ubuntu 12.04.How the preemptive scheduler is implemented.I use the stequeue as a queue. And I create a scheduler thread which is only responsible for the schedule all other threads. All other threads would be in the queue.(Main thread is also a thread in the queue). According to the period which is set, scheduler thread would give each thread this period of time. (Implementation through swapcontext from current running thread and then swapback to the scheduler thread.) And I give a variable (enum preem/non_preem) to check whether current mode is in preemptive mode. In gtthread struct, there is a variable called joined. In preemptive mode, if thread is not joined. Scheduler thread would never schedule CPU time for it except that all threads before it in queue has finished. If it is joined, I choose the RR to schedule the same time for each joined thread. Just loop all the threads in the queue, to check whether it is joined.How to compile your library and run your program.Use the makefile in folder and make command.How you prevent deadlocks in your Dining Philosophers solution.I give a rule to all the Phiosophers that the even Philosopher needs to pick up the right chopstick first. The odd Philosopher needs to pick up the left chopstick first. And same to the in putting down chopsticks.Any thoughts you have on the project, including things that work especially well or which don't work.I have tried different ways to implement the gtthread, first I would like to simply swapcontext between different threads. Then I found it is not so convenient to operate on the main thread. Then I think I need another scheduler thread, just like 0 thread in Linux. So I have created a scheduler thread in gtthread. It seems that everything works great in my test. But when submit it, I found there is some problem in gtthread_join method. I check it for a long time. The reason seems to be the global queue. After gtthread_yield(), all the data suddenly gone! Then I found there is some problems in stequeue. When I use the pop() first to get the front element, then I want to use the enqueue() to put this front element to the back of the queue. It doesn¡¯t work. It would simply remove this front element, which causes the loss of my data. I think this might be the misunderstanding in the stequeue library.I am satisfied with the design of the scheduler_thread, which gives me a lot of convenient to operate different threads. But I am still confused with the problem happened in stequeue and gtthread_join. Also when running my code in the Udacity, I found the there is a problem called joining thread doesn¡¯t wait for the thread it joins to complete. This problem also confuses me. In my mind, the joining thread should stop the thread which calls it.Also, this time, I haven¡¯t finished all my codes correctly because of the lack of time. Next time, I would do more effort on this project.